Если очень кратко - что мы делаем:
Используя ambari API:
 - мы вносим изменения в конфигурацию компонентов (в нашем примере livy2)
 - перезапускаем требуемые сервисы
 - запрашиваем новый blueprint и добавляем его в наш репозиторий.
Для всего этого используем HDP Sandbox, Ansible, Gitlab CI

1) Необходимо установить ansible, делаем по мануалу:
https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html

2) Так же нам понадобиться Gitlab (версии ce), если его нет, то так же устанавливаем по официальным мануалам.

3) Для запуска Gitlab CI установим gitlab-runner и git версии не ниже 2.* (git222)
gitlab-runner обязательно регистрируем на нашем сервере gitlab.
https://docs.gitlab.com/runner/register/index.html 

4) Настройка Ansible
Все хосты и их настройки хранятся по умолчанию в файле /etc/ansible/hosts
Добавим в него хосты которыми хотим управлять. Для примера в в репозитории есть файл с одной группой и одним хостом
Далее необходимо настроить подключение по ssh к управляемому хосту. Генерируем ключ:
ssh-keygen -t rsa
Утилитой ssh-copy-id копируем ключ на удаленный хост
Проверяем: ssh user@host
Повторяем под пользователем gitlab-runner
Далее можно проверить управление с помощью запуска тестовой задачи:
ansible all -m ping

5) После этого на gitlab создаём новый репозиторий. В репозитории мы будем хранить конфиги и playbook ansible, а также будем выполнять нужные CI/CD силами Gitlab CI

6) На сервере с установленным Ansible для тестов можно создать папку и склонировать туда репозиторий, так же для тестов можно предоставить права пользователю gitlab-runner.
Добавление удаленного репозитория, коммиты и пуллы и пушы  - с этим, я думаю, проблем не возникнет.

7) Описание структуры репозитория:

Папка spark2:

Содержит в себе плейбук на обновление конфигурации apache_livy и саму конфигурации livy в формате json.
Первый раз конфигурацию забираем, используя Ambari API (не забудьте поменять логин пароль админа, адрес, имя кластера с учетом регистра):
curl -u admin:$password -sS -G "https://$FQDN_ambari:8080/api/v1/clusters/$clusterName/configurations?type=livy2-conf&tag=INITIAL" \
| jq --arg newtag $(echo version$(date +%s%N)) '.items[] | del(.href, .version, .Config) | .tag |= $newtag | {"Clusters": {"desired_config": .}}' > conf_livy.json

Что же мы сделали? мы подключились к ambari и запросили текущую конфигурацию livy2, затем передали её утилите jq для редактирования, она удалила ненужные поля и 
сгенерировала новый тег для новой версии конфигурации. Мы не сможем загрузить поправленную конфигурацию с тегом текущей конфигурации. Поэтому меняя настройки, 
обязательно надо менять и тег. После того как утилита внесла настройки мы передали эти данные в файл conf_livy.json.
Этот файл мы будем конфигурировать и отправлять на сервер так же использую ambari api.

В плейбуке мы используем модуль uri и метод PUT закидываем новую конфигурацию на сервер (файл conf_livy.json)
После этого используя модуль command curlом вызываем рестарт сервисов который необходимо перезапустить после внесения изменений.
При этом для эксперимента первую часть мы делаем на удаленном хосте и вторую на локальном.

Папка ambari-config:
Тут у нас лежит blueprint.json и плейбук get_json на его обновление
В плейбуке у нас используется модуль uri , так же подключены переменные из group_vars.
При запуске мы удаляем текущий blueprint и скачиваем через ambari api ( http://$FQDN:8080/api/v1/clusters/Sandbox?format=blueprint )
Выполняется на локальном хосте

Папка group_vars
Тут хранятся переменные, в т.ч. зашифрованные через ansible-vault

8)Playbook Gitlab CI
В файле .gitlab-ci.yml мы описываем весь процесс нужной нам автоматизации:
Сейчас там всего 2 stage - обновление конфигурации livy2 ( это запуск плейбука ансибла spark.yaml) и обновление blueprint после внесенных изменений (плейбук get_json.yaml ).
После того как мы получаем новый конфиг мы пушим его в репозиторий gitlab-runnerом, для этого сделаем ему токен и внесём его в переменные.

9) Хранение паролей в переменных.
Чтобы не хранить пароли в репозитории шифруем всё через ansible-vault. В сети много мануалов по этому поводу.
Проще всего это сделать так:
Придумаем/сгенерируем password и добавим его в password-file - он нужен для шифрования данных, echo $password > ~/.vpasswd , это так же обязательно сделать для пользователя 
gitlab-runner чтобы этот пользователь мог расшифровывать переменные.

После этого шифруем с помощью ansible-vault encrypt_string нужные нам пароли используя тот самый парольный файл 
ansible-vault encrypt_string $шифруемый_пароль ---vault-password-file ~/.vpasswd 
Получим зашифровнный пароль и добавим его в переменные.

Теперь при запуске плейбуков с зашифрованными данные необходимо указывать, где лежит файл для расшифровки:
ansible-playbook --vault-password-file ~/.vpasswd playbook.yaml


